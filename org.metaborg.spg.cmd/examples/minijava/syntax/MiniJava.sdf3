module MiniJava

context-free start-symbols

  Program

context-free syntax // Program
  
  Program.Program = <
    <MainClass>

    <{ClassDecl "\n\n"}*>
  >
  
  MainClass.MainClass = <
    class <ID> { 
      public static void main (String[] <ID>) { 
        <Statement> 
        }
    }> 

context-free syntax // Classes

  ClassDecl.Class = <
    class <ID> <ParentDecl;hide>{ 
      <{FieldDecl "\n"}*>
       
      <{MethodDecl "\n"}*> 
    }> 
  
  ParentDecl.NoParent = <> 
  ParentDecl.Parent = <extends <ID> > 
  
  FieldDecl.Field = <<Type> <ID>;>
   
  MethodDecl.Method = <
    public <Type> <ID>(<{ParamDecl ", "}*>) { 
      <{VarDecl "\n"}*> 
      
      <{Statement "\n"}*>
      return <Exp>; 
    }> 
  
  VarDecl.Var = <<Type> <ID>;>
   
  ParamDecl.Param = <<Type> <ID>>
   
  Type.IntType = <int> 
  Type.BoolType = <boolean> 
  Type.IntArrayType = <int[]> 
  Type.ClassType = <<ID>> 
  
context-free syntax // Statements

  Statement.Block = <
  {
    <{Statement "\n"}*>
  }> 
  
  Statement.Assign = <<VarRef> = <Exp>;> 
  
  Statement.ArrayAssign = <<VarRef>[<Exp>] = <Exp>;> 
  
  Statement.If = <
    if(<Exp;text="true">) <Statement>
    else <Statement>> 
  
  Statement.While = <
    while(<Exp;text="true">) <Statement;text="{}">>
     
  Statement.Print = <System.out.println(<Exp>);>
  
context-free syntax // Expressions

  Exp.True      = <true> 
  Exp.False     = <false> 
  Exp.This      = <this>
   
  VarRef.VarRef = <<ID>>
  
  Exp           = <<VarRef>> 
  Exp.Int       = <<INT>> 
  Exp.Not       = <!<Exp>> 
  Exp.Add       = <<Exp> + <Exp>> {left}
  Exp.Sub       = <<Exp> - <Exp>> {left}
  Exp.Mul       = <<Exp> * <Exp>> {left}
  Exp.Lt        = [[Exp] < [Exp]] {left}
  Exp.And       = <<Exp> && <Exp>> {left}
  Exp.Call      = <<Exp>.<ID>(<{Exp ", "}*>)> 
  Exp.NewArray  = <new int[<Exp>]> 
  Exp.Subscript = <<Exp>[<IndexExp>]>
   
  IndexExp = <<Exp>>
   
  Exp.Length = <<Exp>.length> 
  Exp.NewObject = <new <ID>()> 
  Exp = <(<Exp>)> {bracket}
  
context-free priorities

    { Exp.Subscript Exp.Call Exp.Length } 
  > Exp.Not 
  > Exp.Mul 
  > { left : Exp.Add Exp.Sub } 
  > Exp.Lt 
  > Exp.And
  
template options

  keyword -/- [A-Za-z]
  tokenize : ";.[()"

lexical syntax

  INT = [0-9]+ 
  ID = [a-zA-Z] [a-zA-Z0-9\_]* 
  MainID = "main" 
  LAYOUT = [\ \t\n\r] 
  LAYOUT = "//" ~[\n]* [\n] | EOF 
  LAYOUT = BlockComment 
  EOF =  
  BlockComment = "/*" CommPart* "*/" 
  CommPart = BlockComment 
  CommPart = ~[\/\*] 
  CommPart = Asterisk 
  CommPart = Slash 
  Asterisk = [\*] 
  Slash = [\/] 

lexical restrictions

  INT -/- [0-9]
  ID -/- [a-zA-Z0-9\_]
  Asterisk -/- [\/]
  Slash -/- [\*]
  EOF -/- ~[]

context-free restrictions

  LAYOUT? -/- [\ \t\n\r]
  LAYOUT? -/- [\/].[\/]
  LAYOUT? -/- [\/].[\*]

lexical syntax

  ID = "abstract" {reject}
  ID = "assert" {reject}
  ID = "boolean" {reject}
  ID = "break" {reject}
  ID = "byte" {reject}
  ID = "case" {reject}
  ID = "catch" {reject}
  ID = "char" {reject}
  ID = "class" {reject}
  ID = "const" {reject}
  ID = "continue" {reject}
  ID = "default" {reject}
  ID = "do" {reject}
  ID = "double" {reject}
  ID = "else" {reject}
  ID = "enum" {reject}
  ID = "extends" {reject}
  ID = "final" {reject}
  ID = "finally" {reject}
  ID = "float" {reject}
  ID = "for" {reject}
  ID = "goto" {reject}
  ID = "if" {reject}
  ID = "implements" {reject}
  ID = "import" {reject}
  ID = "instanceof" {reject}
  ID = "int" {reject}
  ID = "interface" {reject}
  ID = "long" {reject}
  ID = "native" {reject}
  ID = "new" {reject}
  ID = "package" {reject}
  ID = "private" {reject}
  ID = "protected" {reject}
  ID = "public" {reject}
  ID = "return" {reject}
  ID = "short" {reject}
  ID = "static" {reject}
  ID = "strictfp" {reject}
  ID = "super" {reject}
  ID = "switch" {reject}
  ID = "synchronized" {reject}
  ID = "this" {reject}
  ID = "throw" {reject}
  ID = "throws" {reject}
  ID = "transient" {reject}
  ID = "try" {reject}
  ID = "void" {reject}
  ID = "volatile" {reject}
  ID = "while" {reject}
  ID = "true" {reject}
  ID = "false" {reject}
  ID = "null" {reject}
