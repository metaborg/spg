module static-semantics

imports

  signatures/-
  
signature

  types
  
    TInt()
    TNull()
    TFun(type, type)
    TClass(occurrence)
    TClassDef(occurrence)
  
rules // Regular rules

  init ^ (s) :=
    new s.
  
  [[ Program(dd, e) ^ (s) ]] :=
    Map1 [[ dd ^ (s) ]],
    [[ e ^ (s) : t ]].

// Commented out null, because it generates programs that cannot be solved..
//  [[ Null() ^ (s) : t ]] :=
//    true.
  
  [[ IntValue(_) ^ (_) : TInt() ]] :=
    true.
  
  [[ Var(x) ^ (s) : t ]] :=
    Var{x} -> s,
    Var{x} |-> d,
    d : t.
    
  [[ Add(e1, e2) ^ (s) : TInt() ]] :=
    [[ e1 ^ (s) : TInt() ]],
    [[ e2 ^ (s) : TInt() ]].

  [[ Fun(x, t, e) ^ (s) : TFun(t1, t2) ]] :=
    Var{x} <- s',
    Var{x} : t1,
    [[ t ^ (s) : t1 ]],
    [[ e ^ (s') : t2 ]],
    s' ---> s,
    new s'.

  [[ App(e1, e2) ^ (s) : t2 ]] :=
    t1' <? t1,
    [[ e1 ^ (s) : TFun(t1, t2) ]],
    [[ e2 ^ (s) : t1' ]].

  [[ NewObject(x) ^ (s) : TClass(d) ]] :=
    Class{x} -> s,
    Class{x} |-> d.
    
  [[ Seq(e1, e2) ^ (s) : ty2 ]] :=
    [[ e1 ^ (s) : ty1 ]],
    [[ e2 ^ (s) : ty2 ]].
    
  [[ Class(x, None(), ff) ^ (s) ]] :=
    Class{x} <- s,
    Class{x} ===> s',
    Class{x} : TClassDef(Class{x}),
    s' ---> s,
    Map1 [[ ff ^ (s') ]],
    new s'.
  
  [[ Class(x, Parent(x_parent), ff) ^ (s) ]] :=
    Class{x} <- s,
    Class{x} ===> s',
    Class{x} : TClassDef(Class{x}),
    /* begin parent */
    Class{x_parent} -> s,
    Class{x_parent} |-> d_parent,
    d_parent ?===> s'',
    s' -I-> s'',
    d_parent : TClassDef(d_parent),
    TClass(Class{x}) <! TClass(d_parent),
    /* end parent */
    s' ---> s,
    Map1 [[ ff ^ (s') ]],
    new s'.
  
  [[ Field(x, t, e) ^ (s) ]] :=
    Var{x} <- s,
    Var{x} : ty,
    ty' <? ty,
    [[ t ^ (s) : ty ]],
    [[ e ^ (s) : ty' ]].
    
  [[ FieldOverride(x, e) ^ (s) ]] :=
    Var{x} -> s,
    Var{x} |-> d,
    d : ty,
    ty' <? ty,
    [[ e ^ (s) : ty' ]].
    
  [[ Assign(lhs, e) ^ (s) : t ]] :=
    t' <? t,
    [[ lhs ^ (s) : t ]],
    [[ e ^ (s) : t' ]].
    
  [[ QVar(e, x) ^ (s) : ty ]] :=
    [[ e ^ (s) : TClass(d_class) ]],
    d_class ?===> cs,
    s' -I-> cs,
    Var{x} -> s',
    Var{x} |-> d,
    d : ty,
    new s'.
  
  [[ IntType() ^ (s) : TInt() ]] :=
    true.
    
  [[ FunType(t1, t2) ^ (s) : TFun(t1', t2') ]] :=
    [[ t1 ^ (s) : t1' ]],
    [[ t2 ^ (s) : t2' ]].
    
  [[ ClassType(x) ^ (s) : TClass(d) ]] :=
    Class{x} -> s,
    Class{x} |-> d.

  [[ ClassDefType(x) ^ (s) : TClassDef(d) ]] :=
    Class{x} -> s,
    Class{x} |-> d.

// Lists

  Map1 [[ [x|xs] ^ (s) ]] :=
    [[ x ^ (s) ]],
    Map1 [[ xs ^ (s) ]].
    
  Map1 [[ [] ^ (s) ]] :=
    true.
  
// Auxiliary (for generation)

  [[ Conss(x, xs) ^ (s) ]] :=
    [[ x ^ (s) ]],
    [[ xs ^ (s) ]].
  
  [[ Conss(x, xs) ^ (s) : ty ]] :=
    [[ x ^ (s) : ty ]],
    [[ xs ^ (s) : ty ]].
