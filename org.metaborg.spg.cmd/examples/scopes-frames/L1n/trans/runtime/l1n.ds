module runtime/l1n

imports
  nabl2/runtime/interpreter/scopegraph-api
  nabl2/runtime/interpreter/frame-api
  nabl2/runtime/interpreter/frame-dummy
  ds-signatures/L1n-sig
  
signature
  
signature
  
  constructors
    NumV : Int -> Val
    ClosV : Exp * FrameId -> Val

	// These should be implicitly defined
	native operators
		getExpScopes : Exp -> List(Scope)
		getExpType : Exp -> Type
		getOccurrence : ID -> Occurrence // This should probably be axiomatized in Coq

	sorts Unit constructors
		tt : Unit

	// Ceci n'est pas un tuple ...
	sorts FrameListExpListOccTuple constructors
		FLELO : FrameId * List(Exp) * List(Occurrence) -> FrameListExpListOccTuple

  arrows
    Exp --> Val
    FrameListExpListOccTuple -fill_par-> Unit

  native operators
    parseI : String -> Int
    plusI  : Int * Int -> Int
    
rules
  
  IntValue(i) --> NumV(parseI(i)).

  f |- Var(r) :: h --> v :: h
  where
    pathOfRef(getOccurrence(r)) => p;
    f, h |- p -lookup-> Addr(f', d);
    f', h |- d -get-> v.
  
  Add(e1, e2) --> NumV(plusI(z1, z2))
  where
    e1 --> NumV(z1);
    e2 --> NumV(z2).
  
  f |- Fun(_, e) --> ClosV(e, f).
  
  f |- App(e1, e2s) --> v'
  where
    f |- e1 --> ClosV(e', f') :: h;
    getExpScopes(e') => [s];
    declsOfScope(s) => ds;
    f', h |- scopeOf() -scopeOf-> s';
    SL(s, {P() |--> {s' |--> f'}}) -initDefault-> f'';
    f'' |- FLELO(f, e2s, ds) -fill_par-> tt();
    f'' |- e' --> v'.

rules

	FLELO(_, [], []) -fill_par-> tt().

	f' |- FLELO(f, [e|es], [d|ds]) -fill_par-> v'
	where
		f |- e --> v :: h;
		f', h |- OV(d, v) -set-> _ :: h';
		f' |- FLELO(f, es, ds) :: h' -fill_par-> v'.
