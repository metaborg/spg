module static-semantics

imports

  signatures/-
  
signature

  types
    
    TInt()
    TBool()
    TIntArray()
    TMainClass()
    TClass(occurrence)
    TMethod(type, List(type))
  
//  // This "special" resolution parameters are added for detecting overloading
//  name resolution
//  
//    labels          S
//    order           S < I, S < P, D < S
//    well-formedness P*.(e | (S.I)).I*

rules // Program

  init ^ (s) :=
    new s.

  [[ Program(mc, cc) ^ (s) ]] :=
    !D(s)/Class | error "Duplicate class" @NAMES,
    [[ mc ^ (s) ]],
    Map1 [[ cc ^ (s) ]].

  [[ MainClass(x, _, st) ^ (s) ]] :=
    Class{x} <- s,
    Class{x} : TMainClass(),
    [[ st ^ (s) ]].

rules // Classes

  [[ Class(x, p, ff, mm) ^ (s) ]] :=
    Class{x} <- s,
    Class{x} ===> cs,
    Class{x} : ty,
    ty == TClass(Class{x}),
    Implicit{"this"} <- cs,
    Implicit{"this"} : TClass(Class{x}),
    // Prevent duplicate fields
    !D(cs)/Var | error "Duplicate field" @NAMES,
    // Prevent duplicate methods
    !D(cs)/Method | error "Duplicate method" @NAMES,
    // Union of fields `D(cs)/Var` with inherited fields `(W(cs)/Var minus D(cs)/Var)` should be distinct. Not supported by generator..
    //!(D(cs)/Var union (W(cs)/Var minus D(cs)/Var)) | error "Field hides inherited field" @NAMES,
    cs ---> s,
    [[ p ^ (s, cs) : ty ]],
    Map1 [[ ff ^ (cs) ]],
    Map1 [[ mm ^ (cs) ]],
    new cs.
  
  [[ Parent(x) ^ (s, cs) : ty ]] :=
    Class{x} -> s,
    Class{x} <=== cs,
    Class{x} |-> d_parent,
    d_parent : ty1,
    ty1 != TMainClass() | error "Cannot inherit from main class" @x,
    ty <! ty1.
  
  [[ NoParent() ^ (s, cs) : ty ]] :=
    true.
  
  [[ Field(c, x) ^ (s) ]] :=
    Var{x} <- s,
    Var{x} : ty,
    [[ c ^ (s) : ty ]].

  [[ Method(c, x, aa, vv, ss, e) ^ (s) ]] :=
    Method{x} <- s,
    Method{x} : TMethod(cty, aaty),
//    Method{x} -> s',
//    Method{x} |-> d_m,
//    s' -I-> s,
//    s' -S-> s,

//    d_m : TMethod(cty', aaty'),
//    cty <? cty' | error "Erroneous overriding" @x,
//    aaty' == aaty | error "Overloading" @x,
    [[ c ^ (s) : cty ]],
    ms ---> s,
    !D(ms)/Var | error "Multiple definitions for variable" @NAMES,
    // D(ms)/Var # D(s)/Var | warning "Variable hides local field" @NAMES,
    Map1T [[ aa ^ (ms) : aaty ]],
    Map1 [[ vv ^ (ms) ]],
    Map1 [[ ss ^ (ms) ]],
    [[ e ^ (ms) : ety ]],
    ety <? cty | error "Type mismatch in return expression" @e,
    new as,
    new ms
//    new s'
    .
  
  [[ Param(c, x) ^ (s) : ty ]] :=
    Var{x} <- s,
    Var{x} : ty,
    [[ c ^ (s) : ty ]].

  [[ Var(c, x) ^ (s) ]] :=
    Var{x} <- s,
    Var{x} : ty,
    [[ c ^ (s) : ty ]].

  // Types
  
  [[ IntType() ^ (s) : ty ]] :=
    ty == TInt().

  [[ BoolType() ^ (s) : ty ]] :=
    ty == TBool().
  
  [[ IntArrayType() ^ (s) : ty ]] :=
    ty == TIntArray().
  
  [[ ClassType(x) ^ (s) : TClass(d_class) ]] :=
    Class{x} -> s,
    Class{x} |-> d_class,
    d_class : ty,
    ty != TMainClass() | error "Cannot refer to main class" @x.
  
rules // Statements

  [[ Block(ss) ^ (s) ]] :=
    Map1 [[ ss ^ (s) ]].

  [[ Assign(v, e) ^ (s) ]] :=
    [[ v ^ (s) : ty1 ]],
    [[ e ^ (s) : ty2 ]],
    ty1 <? ty2 | error "Type mismatch in assignment" @v.

  [[ ArrayAssign(v, e1, e2) ^ (s) ]] :=
    [[ v ^ (s) : ty1 ]],
    ty1 == TIntArray() | error "Integer array expected" @v,
    [[ e1 ^ (s) : ty2 ]],
    ty2 == TInt() | error "Integer expected" @e1,
    [[ e2 ^ (s) : ty3 ]],
    ty3 == TInt() | error "Integer expected" @e2.
    
  [[ If(e, s1, s2) ^ (s) ]] :=
    [[ e ^ (s) : ty ]],
    ty == TBool() | error "Boolean condition expected" @e,
    [[ s1 ^ (s) ]],
    [[ s2 ^ (s) ]].
    
  [[ While(e, st) ^ (s) ]] :=
    [[ e ^ (s) : ty ]],
    ty == TBool() | error "Boolean condition expected" @e,
    [[ st ^ (s) ]].
    
  [[ Print(e) ^ (s) ]] :=
    [[ e ^ (s) : ty ]],
    ty == TInt() | error "Integer expected" @e.

rules // Expressions

  [[ VarRef(id) ^ (s) : ty ]] :=
    Var{id} -> s,
    Var{id} |-> d,
    d : ty.
    
  [[ True() ^ (s) : TBool() ]] :=
    true.
    
  [[ False() ^ (s) : TBool() ]] :=
    true.
  
  [[ This() ^ (s) : ty ]] :=
    Implicit{"this"} -> s,
    Implicit{"this"} |-> d,
    d : TClass(x),
    ty == TClass(x).
  
  [[ Int(_) ^ (s) : TInt() ]] :=
    true.
  
  [[ Not(e) ^ (s) : TBool() ]] :=
    [[ e ^ (s) : ty ]],
    ty == TBool() | error "Type mismatch" @e.
    
  [[ Add(e1, e2) ^ (s) : TInt() ]] :=
    [[ e1 ^ (s) : ty1 ]],
    ty1 == TInt() | error "Type mismatch" @e1,
    [[ e2 ^ (s) : ty2 ]],
    ty2 == TInt() | error "Type mismatch" @e2.

  [[ Sub(e1, e2) ^ (s) : TInt() ]] :=
    [[ e1 ^ (s) : ty1 ]],
    ty1 == TInt() | error "Type mismatch" @e1,
    [[ e2 ^ (s) : ty2 ]],
    ty2 == TInt() | error "Type mismatch" @e2.
    
  [[ Mul(e1, e2) ^ (s) : TInt() ]] :=
    [[ e1 ^ (s) : ty1 ]],
    ty1 == TInt() | error "Type mismatch" @e1,
    [[ e2 ^ (s) : ty2 ]],
    ty2 == TInt() | error "Type mismatch" @e2.

  [[ Lt(e1, e2) ^ (s) : TBool() ]] :=
    [[ e1 ^ (s) : ty1 ]],
    ty1 == TInt() | error "Type mismatch" @e1,
    [[ e2 ^ (s) : ty2 ]],
    ty2 == TInt() | error "Type mismatch" @e2.

  [[ And(e1, e2) ^ (s) : TBool() ]] :=
    [[ e1 ^ (s) : ty1 ]],
    ty1 == TBool() | error "Type mismatch" @e1,
    [[ e2 ^ (s) : ty2 ]],
    ty2 == TBool() | error "Type mismatch" @e2.

  [[ Call(e, x, ee) ^ (s) : frty ]] :=
    [[ e ^ (s) : TClass(d) ]],
    d ?=I=> cs,
    s' -I-> cs,
    Method{x} -> s',
    Method{x} |-> m,
    m : TMethod(frty, faaty),
    Map1T [[ ee ^ (s) : aaaty ]],
    aaaty <? faaty | error "Type mismatch in method arguments" @x,
    new s'.
  
  [[ NewArray(e) ^ (s) : TIntArray() ]] :=
    [[ e ^ (s) : ty ]],
    ty == TInt() | error "Type mismatch" @e.

  [[ Subscript(e1, e2) ^ (s) : TInt() ]] :=
    [[ e1 ^ (s) : ty1 ]],
    ty1 == TIntArray() | error "Type mismatch" @e1,
    [[ e2 ^ (s) : ty2 ]],
    ty2 == TInt() | error "Type mismatch" @e2.

  [[ Length(e) ^ (s) : TInt() ]] :=
    [[ e ^ (s) : ty ]],
    ty == TIntArray() | error "Type mismatch" @e.
  
  [[ NewObject(x) ^ (s) : ty ]] :=
    Class{x} -> s,
    Class{x} |-> d_class,
    d_class : TClass(d_class),
    ty == TClass(d_class),
    ty != TMainClass() | error "Cannot instantiate main class" @x.

rules // Auxiliary for generation
  
  // List
  Map1 [[ [x|xs] ^ (s) ]] :=
    [[ x ^ (s) ]],
    Map1 [[ xs ^ (s) ]].
  
  Map1 [[ [] ^ (s) ]] :=
    true.
  
  Map1T [[ [x|xs] ^ (s) : [ty|tys] ]] :=
    [[ x ^ (s) : ty ]],
    Map1T [[ xs ^ (s) : tys ]].
  
  Map1T [[ [] ^ (s) : [] ]] :=
    true.
  
  // Iter
  [[ Conss(x, y) ^ (s) ]] :=
    [[ x ^ (s) ]], [[ y ^ (s) ]].
  
  [[ Conss(x, y) ^ (s) : ty ]] :=
    [[ x ^ (s) : ty ]], [[ y ^ (s) : ty ]].

  // Option
  [[ Some(x) ^ (s) ]] :=
    [[ x ^ (s) ]].
    
  [[ None() ^ (s) ]] :=
    true.
  