module static-semantics

imports signatures/-
imports trans/-

signature
  name resolution
    namespaces
      Type Var Field Loop
    labels 
      P I 
    well-formedness 
      P* . I*
    order
      D < P, 
      D < I, 
      I < P
  
  types
    UNIT()
    INT()
    STRING()
    NIL()
    RECORD(scope)
    ARRAY(type, scope)
    FUN(type, type)
    TC1()
    TC2(type)
    TC3(scope)
    TC4(type, scope, type)

rules

// Module statics/base

  init ^ (s) : ty_init := 
    new s,               // the root scope
    
    Type{"int"} <- s,    // declare primitive type int
    Type{"int"} : INT() !!,
    
    Type{"string"} <- s, // declare primitive type string
    Type{"string"} : STRING() !!,
    
    // standard library
    
    Var{"print"} <- s,   
    Var{"print"} : FUN([STRING()], UNIT()) !!,
    
    Var{"flush"} <- s,   
    Var{"flush"} : FUN([], UNIT()) !!,
    
    Var{"getchar"} <- s,   
    Var{"getchar"} : FUN([], STRING()) !!,
    
    Var{"ord"} <- s,   
    Var{"ord"} : FUN([STRING()], INT()) !!,
    
    Var{"chr"} <- s,   
    Var{"chr"} : FUN([INT()], STRING()) !!,
    
    Var{"size"} <- s,   
    Var{"size"} : FUN([STRING()], INT()) !!,
    
    Var{"substring"} <- s,   
    Var{"substring"} : FUN([STRING(), INT(), INT()], STRING()) !!,
    
    Var{"concat"} <- s,   
    Var{"concat"} : FUN([STRING(), STRING()], STRING()) !!,
    
    Var{"not"} <- s,   
    Var{"not"} : FUN([INT()], INT()) !!,
    
    Var{"exit"} <- s,   
    Var{"exit"} : FUN([INT()], UNIT()) !!.

// Module statics/tiger

  // top-level module

  [[ Mod(e) ^ (s) : ty ]] :=
     [[ e ^ (s) : ty ]].

  // array type
     
  [[ ArrayTy(t) ^ (s) : ARRAY(ty, s')]] := 
     new s', // unique token to distinghuish the array type
     [[ t ^ (s) : ty ]].

  // array creation
     
  [[ Array(t, length, initial) ^ (s) : ty ]] :=
     [[ t ^ (s) : ARRAY(ty_indic, s_arr) ]],
     ty == ARRAY(ty_indic, s_arr) | error $[array type expected],
     ty_elem <? ty_indic | error $[type mismatch [ty_indic] expected] @ initial,
     [[ length ^ (s) : INT() ]],
     [[ initial ^ (s) : ty_elem ]].
     
  // array indexing
     
  [[ Subscript(e1, e2) ^ (s) : ty ]] :=
     [[ e1 ^ (s) : ty_arr ]],
     ty_arr == ARRAY(ty, s_arr),
     [[ e2 ^ (s) : INT() ]].
    
// Module statics/bindings

  [[ Let(blocks, exps) ^ (s) : ty ]] :=
     new s_body,
     Decs [[ blocks ^ (s, s_body) ]],
     Seq [[ exps ^ (s_body) : ty ]],
     distinct D(s_body).
     
  Decs [[ [] ^ (s_outer, s_body) ]] :=
    s_body -P-> s_outer.
    
  Decs [[ [block] ^ (s_outer, s_body) ]] :=
    s_body -P-> s_outer,
    Dec [[ block ^ (s_body, s_outer) ]].

  Decs [[ [block | blocks@[_|_]] ^ (s_outer, s_body) ]] :=
    new s_dec, 
    s_dec -P-> s_outer,
    Dec [[ block ^ (s_dec, s_outer) ]],
    Decs [[ blocks ^ (s_dec, s_body) ]],
    distinct D(s_dec) | error $[duplicate declaration] @NAMES.

// Module constraints
  
//  [[ Constr(e1, e2) ^ (s) ]] :=
//    [[ e ^ (s) : ty ]], // generate constraints for sub-term
//    //  C1, C2 // conjuction of constraints
//    new s,  // generate a new scope
//         
//    NS{x} <- s, // declaration of name x in namespace NS
//    NS{x} -> s, // reference of name x in namespace NS
//         
//    s ---> s',    // unlabeled scope edge from s to s'
//    s -L-> s',  // scope edge from s to s' labeled L
//         
//    NS{x} |-> d, // resolve reference x in namespace NS to declaration d
//    
//    distinct D(s)/NS, // declarations for NS in s should be distinct
//    
//    D(s1) subseteq R(s2), // name set 
//    
//    D(s_rec)/Field subseteq R(s_use)/Field | error $[Field [NAME] not initialized] @r,
//    
//    [[ e ^ (s) : ty ]], // subterm e has type ty under scope s
//    
//    o : ty, // occurrence o has type ty
//    
//    o : ty !, // with priority
//    
//    ty1 == ty2, // ty1 and ty2 should unify
//    
//    ty <! ty2, // declare ty1 a subtype of ty2
//    
//    ty1 <? ty2, // is ty1 a subtype of ty1?
//         
//    false | error $[something is wrong], // custom error message
//    false | warning $[does not look right], // custom warning
//         
//    false, // always fails
//    true. // always succeeds
  
// Module statics/control-flow

  // sequence

  Seq [[ [] ^ (s) : UNIT() ]] := 
    true.  
   
  Seq [[ [e] ^ (s) : ty ]] :=
    [[ e ^ (s) : ty ]].
    
  Seq [[ [ e | es@[_|_] ] ^ (s) : ty ]] :=
    [[ e ^ (s) : ty' ]],
    Seq [[ es ^ (s) : ty ]].
    
  [[ Seq(es) ^ (s) : ty ]] :=
     Seq [[ es ^ (s) : ty ]].
     
  [[ If(e1, e2, e3) ^ (s) : ty2 ]] := 
     [[ e1 ^ (s) : INT() ]], 
     [[ e2 ^ (s) : ty2 ]], 
     [[ e3 ^ (s) : ty3 ]],
     ty2 == ty3 | error $[branches should have same type].
     
  [[ IfThen(e1, e2) ^ (s) : UNIT() ]] := 
     [[ e1 ^ (s) : INT() ]], 
     [[ e2 ^ (s) : UNIT() ]].
     
  [[ stm@While(e1, e2) ^ (s) : UNIT() ]] := 
     new s_while, s_while -P-> s,
     Loop{Break()@stm} <- s_while,
     [[ e1 ^ (s) : INT() ]], 
     [[ e2 ^ (s_while) : UNIT() ]].

  [[ stm@For(Var(x), e1, e2, e3) ^ (s) : UNIT() ]] := 
     new s_for, 
     s_for -P-> s,
     Var{x} <- s_for,
     Var{x} : INT(),
     Loop{Break()@stm} <- s_for,
     [[ e1 ^ (s) : INT() ]], // x not bound in loop bounds
     [[ e2 ^ (s) : INT() ]], 
     [[ e3 ^ (s_for) : UNIT() ]]. // x bound in body
     
  [[ stm@Break() ^ (s) : UNIT() ]] := 
     Loop{Break()@stm} -> s,
     Loop{Break()@stm} |-> d.

// Module statics/functions

 // function declarations

  // Parameters: In [function id(... id1: id2 ...) = exp] the
  // scope of the parameter id1 lasts throughout the function
  // body exp
        
  Dec [[ FunDecs(fdecs) ^ (s, s_outer) ]] :=
     Map2 [[ fdecs ^ (s, s_outer) ]].
     
  [[ ProcDec(f, args, e) ^ (s, s_outer) ]] :=
//     Args[[ args ^ (s_fun, s_outer) : tys ]], 
     new s_fun,      
     s_fun -P-> s,   
     distinct D(s_fun) | error $[duplicate argument] @ NAMES, 
     MapTs2 [[ args ^ (s_fun, s_outer) : tys ]],
//
     Var{f} <- s, 
     Var{f} : FUN(tys, UNIT()) !, 
     [[ e ^ (s_fun) : UNIT() ]].
        
  [[ FunDec(f, args, t, e) ^ (s, s_outer) ]] :=
//     Args[[ args ^ (s_fun, s_outer) : tys ]], 
     new s_fun,      
     s_fun -P-> s,   
     distinct D(s_fun) | error $[duplicate argument] @ NAMES, 
     MapTs2[[ args ^ (s_fun, s_outer) : tys ]],
    [[ t ^ (s_outer) : ty ]],
     Var{f} <- s, 
     Var{f} : FUN(tys, ty) !, 
     [[ e ^ (s_fun) : ty_body ]],
     ty == ty_body| error $[return type does not match body] @ t.
     
//  Args [[ args ^ (s_fun, s_outer) : tys ]] := 
//     new s_fun,      
//     s_fun -P-> s,   
//     distinct D(s_fun) | error $[duplicate argument] @ NAMES, 
//     MapTs2[[ args ^ (s_fun, s_outer) : tys ]].
     
  [[ FArg(x, t) ^ (s_fun, s_outer) : ty ]] :=
     Var{x} <- s_fun, 
     Var{x} : ty !,
     [[ t ^ (s_outer) : ty ]].
     
 // function calls
    
  [[ Call(f, exps) ^ (s) : ty ]] :=
     Var{f} -> s,  
     Var{f} |-> d | error $[Function [f] not declared], 
     d : FUN(tys, ty) | error $[Function expected] ,
     MapSTs[[ exps ^ (s) : tys ]].
     
     // todo: error messages per argument

// Module statics/nabl-lib

 // auxiliary

  [[ None() ^ (s) ]] := true.
  [[ Some(e) ^ (s) ]] := [[ e ^ (s) ]].

  Map [[ [] ^ (s) ]] := true.   
  Map [[ [ x | xs ] ^ (s) ]] := 
    [[ x ^ (s) ]], Map [[ xs ^ (s) ]].
    
  Map2[[ [] ^ (s, s') ]] := true.   
  Map2[[ [ x | xs ] ^ (s, s') ]] := 
    [[ x ^ (s, s') ]], Map2[[ xs ^ (s, s') ]].
    
  MapT2[[ [] ^ (s, s') : [] ]] := true.   
  MapT2[[ [ x | xs ] ^ (s, s') : [ty | tys] ]] := 
    [[ x ^ (s, s') : ty ]], MapT2[[ xs ^ (s, s') : tys ]].
   
  MapT[[ [] ^ (s) : ty ]] := true.   
  MapT[[ [ x | xs ] ^ (s) : ty ]] := 
    [[ x ^ (s) : ty ]], MapT[[ xs ^ (s) : ty ]].
   
  MapTs[[ [] ^ (s) : [] ]] := true.   
  MapTs[[ [ x | xs ] ^ (s) : [ty1 | tys] ]] := 
    [[ x ^ (s) : ty2 ]], 
    ty1 == ty2 | error $[type mismatch] @ x,
    MapTs[[ xs ^ (s) : tys ]].
   
  MapSTs[[ [] ^ (s) : [] ]] := true.   
  MapSTs[[ [ x | xs ] ^ (s) : [ty1 | tys] ]] := 
    [[ x ^ (s) : ty2 ]], 
    ty2 <? ty1 | error $[type [ty1] expected] @ x,
    MapTs[[ xs ^ (s) : tys ]].
   
  MapTs2[[ [] ^ (s1, s2) : [] ]] := true.   
  MapTs2[[ [ x | xs ] ^ (s1, s2) : [ty | tys] ]] := 
    [[ x ^ (s1, s2) : ty ]], MapTs2[[ xs ^ (s1, s2) : tys ]].

// Module statics/numbers

 // literals    

  [[ Int(i) ^ (s) : INT() ]] := true.  
  
 // operators
  
  // Arithmetic
  [[ Uminus(e) ^ (s) : INT() ]] :=
     [[ e ^ (s) : INT() ]].
          
  [[ Divide(e1, e2) ^ (s) : INT() ]] :=
     [[ e1 ^ (s) : INT() ]], [[ e2 ^ (s): INT() ]].
     
  [[ Times(e1, e2) ^ (s) : INT() ]] :=
     [[ e1 ^ (s) : INT() ]], [[ e2 ^ (s): INT() ]].
     
  [[ Minus(e1, e2) ^ (s) : INT() ]] :=
     [[ e1 ^ (s) : INT() ]], [[ e2 ^ (s): INT() ]].
     
  [[ Plus(e1, e2) ^ (s) : INT() ]] :=
     [[ e1 ^ (s) : INT() ]], [[ e2 ^ (s): INT() ]].
  
  // Comparison
  [[ Eq(e1, e2) ^ (s) : INT() ]] :=
     [[ e1 ^ (s) : ty1 ]], [[ e2 ^ (s): ty2 ]],
     ty1 == ty2,
     ty1 != FUN(a_, b_).
     // Disjunction is not supported by generator.
     // ((ty1 == ty2) ; ((ty1 <? ty2) ; (ty2 <? ty1))).
        
  [[ Neq(e1, e2) ^ (s) : INT() ]] :=
     [[ e1 ^ (s) : INT() ]], [[ e2 ^ (s): INT() ]].
    
  [[ Gt(e1, e2) ^ (s) : INT() ]] :=
     [[ e1 ^ (s) : INT() ]], [[ e2 ^ (s): INT() ]].
        
  [[ Lt(e1, e2) ^ (s) : INT() ]] :=
     [[ e1 ^ (s) : INT() ]], [[ e2 ^ (s): INT() ]].
  
  [[ Geq(e1, e2) ^ (s) : INT() ]] :=
     [[ e1 ^ (s) : INT() ]], [[ e2 ^ (s): INT() ]].
  
  [[ Leq(e1, e2) ^ (s) : INT() ]] :=
     [[ e1 ^ (s) : INT() ]], [[ e2 ^ (s): INT() ]].
  
  // Boolean operators
  [[ Or(e1, e2) ^ (s) : INT() ]] :=
     [[ e1 ^ (s) : t1 ]], [[ e2 ^ (s): t2 ]], t1 == t2.
  
  [[ And(e1, e2) ^ (s) : INT() ]] :=
     [[ e1 ^ (s) : t1 ]], [[ e2 ^ (s): t2 ]], t1 == t2.
     
// Module statics/records

 // record type

  [[ RecordTy(fields) ^ (s) : ty ]] := 
     new s_rec,
     ty == RECORD(s_rec),
     NIL() <! ty,
     distinct D(s_rec)/Field | error $[Duplicate declaration of field [NAME]] @ NAMES,
     Map2[[ fields ^ (s_rec, s) ]].
     
  [[ Field(x, t) ^ (s_rec, s_outer) ]] :=
     Field{x} <- s_rec,
     Field{x} : ty !,
     [[ t ^ (s_outer) : ty ]].

 // literals    

  [[ NilExp() ^ (s) : NIL() ]] := true.

 // record creation   
   
  [[ Record(t, inits) ^ (s) : ty ]] :=
     [[ t ^ (s) : ty ]],
     ty == RECORD(s_rec) | error $[record type expected],
     new s_use, s_use -I-> s_rec,
     D(s_rec)/Field subseteq R(s_use)/Field | error $[Field [NAME] not initialized],
     Map2 [[ inits ^ (s_use, s) ]].
         
  [[ InitField(x, e) ^ (s_use, s) ]] :=
     Field{x} -> s_use,
     Field{x} |-> d,
     d : ty1,
     [[ e ^ (s) : ty2 ]],
     ty2 <? ty1 | error $[type mismatch].
      
 // record field access
     
  [[ FieldVar(e, f) ^ (s) : ty ]] :=
     [[ e ^ (s) : ty_e ]], 
     ty_e == RECORD(s_rec),
     new s_use, s_use -I-> s_rec, 
     Field{f} -> s_use,
     Field{f} |-> d,
     d : ty.

// Module statics/strings


 // literals    

  [[ String(str) ^ (s) : STRING() ]] := true.

// Module statics/types


 // type declarations

  // Types: In the expression [let ... typedecs ... in exps end] the
  // scope of a type identifier starts at the beginning of the 
  // consecutive sequence of type declarations defining it and lasts
  // until the end. The includes the headers and bodies of any functions
  // with the scope.
  
  // Name spaces: There are two different name spaces: one for types,
  // and one for functions and variables. A type [a] can be "in scope"
  // at the same time as a variable [a] or a function [a], but 
  // variables and functions of the same name cannot both be in 
  // scope simultaneously (one will hide the other).
    
  Dec [[ TypeDecs(tdecs) ^ (s, s_outer) ]] := 
     Map [[ tdecs ^ (s) ]].
     
  [[ TypeDec(x, t) ^ (s) ]] :=
     [[ t ^ (s) : ty ]],
     Type{x} <- s, 
     Type{x} : ty !.
     
   // type declarations in a sequence are mutually recursive

 // types

  [[ Tid(x) ^ (s) : ty ]] :=
     Type{x} -> s, 
     Type{x} |-> d | error $[Type [x] not declared],
     d : ty.

// Module statics/variables

 // variable declarations

  // Local variables: In the expression [let ... vardec ... in exp end], 
  // the scope of the declared variable starts just after its vardec 
  // and lasts until the end.

  Dec [[ VarDec(x, t, e) ^ (s, s_outer) ]] :=
     [[ t ^ (s_outer) : ty1 ]],
     [[ e ^ (s_outer) : ty2 ]],
     ty2 <? ty1 | error $[type mismatch [ty1] expected] @ e,
     Var{x} <- s, 
     Var{x} : ty1 !.
     
  Dec [[ VarDecNoType(x, e) ^ (s, s_outer) ]] :=
     [[ e ^ (s_outer) : ty ]],
     ty != NIL() | error $[explicit type expected for variable initialized with nil],
     Var{x} <- s, 
     Var{x} : ty !.
         
  // variable references
  
  [[ Var(x) ^ (s) : ty ]] :=
     Var{x} -> s,  // declare x as variable reference
     Var{x} |-> d, // check that x resolves to a declaration
     d : ty.       // type of declaration is type of reference
 
  // statements

  [[ Assign(e1, e2) ^ (s) : UNIT() ]] :=
     [[ e1 ^ (s) : ty1 ]], 
     [[ e2 ^ (s) : ty2 ]],
     ty2 <? ty1 | error $[type mismatch [ty1] expected] @ e2.  

// For generation

  [[ Conss(x, xs) ^ (s) ]] :=
    [[ x ^ (s) ]],
    Map [[ xs ^ (s) ]].
    
  Map [[ Conss(x, xs) ^ (s) ]] :=
    [[ x ^ (s) ]],
    Map [[ xs ^ (s) ]].
    
  Map2 [[ Conss(x, xs) ^ (s1, s2) ]] :=
    [[ x ^ (s1, s2) ]],
    Map2 [[ xs ^ (s1, s2) ]].
  
// Repeated for larger lists in generation

  Decs [[ [block | blocks@[_|_]] ^ (s_outer, s_body) ]] :=
    new s_dec, 
    s_dec -P-> s_outer,
    Dec [[ block ^ (s_dec, s_outer) ]],
    Decs [[ blocks ^ (s_dec, s_body) ]],
    distinct D(s_dec) | error $[duplicate declaration] @NAMES.
    
  Seq [[ [ e | es@[_|_] ] ^ (s) : ty ]] :=
    [[ e ^ (s) : ty' ]],
    Seq [[ es ^ (s) : ty ]].
  
